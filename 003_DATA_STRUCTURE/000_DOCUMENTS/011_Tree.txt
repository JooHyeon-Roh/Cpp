https://m.blog.naver.com/justkukaro/220548164184
http://dblab.duksung.ac.kr/ds/pdf/Chap08.pdf
https://smujihoon.tistory.com/153

1. 정의 및 특징
	- 트리는 1개 이상의 노드를 갖는 집합으로 노드들은 다음 조건을 만족한다.
		- 트리에는 루트(root)라고 부르는 특별한 노드가 있다.
		- 다른 노드들은 원소가 중복되지 않는 n개의 부속 트리 (subtree)
				- T1, T2,···, Tn으로 나누어지며 Ti 각각은 루트의 부속 트리라고 부른다.
				-그래프의 한 종류이다. '최소 연결 트리' 라고도 불린다.

	- 트리는 계층 모델이다.
	- 트리는 DAG(Directed Acyclic Graphs, 방향성이 있는 비순환 그래프)의 한 종류이다.
	- loop나 circuit이 없다. 당연히 self-loop도 없다.
	- 노드가 N개인 트리는 항상 N-1개의 간선을 가진다.
	- 루트에서 어떤 노드로 가는 경로는 유일하다.
	- 한 개의 루트 노드만이 존재하며 모든 자식 노드는 한 개의 부모 노드만을 가진다.
	- 순회는 Pre-order, In-order 아니면 Post-order로 이루어진다. 이 3가지 모두 DFS/BFS안에 있다.
	- 트리는 이진트리, 이진탐색트리, 균형트리(AVL트리, red-black트리), 이진 힙(최대힙, 최소힙) 등이 있다.
				
	-트리에 관한 용어
		- Root(뿌리) 노드 - 최상위 노드
		- Child(자식) 노드 - 어떤 노드의 하위 노드
		- Parent(부모) 노드 - 어떤 노드의 상위 노드
		- Brother,Sibling(형제) 노드 - 어떤 노드의 같은 등급의 노드
		- Leaf(잎) 노드 - 자식 노드가 존재하지 않는 노드
		- Branch(가지) 노드 - 자식 노드가 하나라도 존재하는 노드중에 Root가 아닌 노드
		- ancestor(조상) - 노드의 부모 노드들의 총 집합
		- internal, non-terminal(내부) 노드 : 차수가 1 이상인 노드
		
		- 깊이(Depth) - 루트에서 어떤 노드까지의 경로의 갯수
		- 레벨(Level) - 같은 깊이의 집합
		- 높이(Height) - 이 트리에서 가장 높은 깊이
		- 차수(Degree) - 어떠한 노드의 자식의 갯수 
	
2. 추상 자료형(ADT)
	- 추상 자료형 정의
	
	

		
4. 표현법
	- N링크 표현법(N-Link Expression)
		- N링크 표현법은 트리라는 자료구조를 가장 극명하게 나타낸다고 할 수 있습니다.
		- 하나의 자료가 최대 N개의 자식을 가지게 되며 그 자식 또한 최대 N개의 자식을 가지게됩니다.
		- 각각의 노드는 그 노드에 걸맞는 데이터와 자식들을 가지게 되며 자신의 자식들의 정보에 바로 접근 할 수 있습니다.
	
		- 장점
			= 트리 그자체를 직관적으로 표시하였기 때문에 잘 구현만 해놨다면 이용에 직관적.
			= 시간복잡도가 우수하다.
			
		- 단점
			= 구현이 복잡하다.
			= 자식의 갯수는 최대 N개로 고정.
			
		- 시간 복잡도(Time Complexity)
			- 삽입
				= 삽입하는 경우 : Insert(1) = Big-O Notation = O(1)
			- 삭제
				= 삭제하는 경우 : Remove(n) = Big-O Notation = O(n) 
			- 탐색
				= Retrieve(n) = Big-O Notation = O(n)
			

	- 왼쪽자식/오른쪽형제 표현법(Left Child/Right Sibling Expression)
		- 장점
			= 구현이 N 링크방식에 비해서는 매우 쉬운편.
			= 늘어나는 데이터에도 효과적으로 만들 수 있다.(N링크 표현법을 동적으로 만들면 장점이 안될 수 있으나, N링크 표현법 구현이 더 복잡해진다.)
			
		- 단점
			= 부모노드에서 자식느도를 한방에 방문할 방법이 전무.
			
		- 시간 복잡도(Time Complexity)
			- 삽입
				= 삽입하는 경우 : Insert(n) = Big-O Notation = O(n)
			- 삭제
				= 삭제하는 경우 : Remove(n) = Big-O Notation = O(n) 
			- 탐색
				= Retrieve(n) = Big-O Notation = O(n)