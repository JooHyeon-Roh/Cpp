1. 정의 및 특징
	- 서로 연관된 같은 자료형의 데이터를 순차적으로 일렬로 저장할때 사용하는 선형 자료구조.
	- 메모리 상에서 물리적으로 순차적으로 저장하는 특징.
	- 인덱스와 요소가 쌍을 이루는 집합.
	- 각 요소는 자료형과 기억 공간의 크기가 동일.
	- 인덱스(논리적인 순서)는 메모레에 저장되는 메모리 주소(물리적인 순서)와 동일.
	- 인덱스를 사용하여 직접 접근
	- 요소의 첫 번째 메모리 주소와 인덱스를 통하여 특정 요소의 메모리 주소를 계산할 수 있다.
		(array.drawio / 1. 정의 및 특징 참조)
	
2. 배열의 추상 자료형(ADT)
	- Object
		<i∈Index, item∈Element> 쌍들의 집합. index는 순서를 나타내는 정수의 유한집합, Element는 자료형이 같은 요소의 집합
	- Function
		arr∈Array; i∈index; x, item∈Element, n∈Integer에 대해 아래와 같은 연산이 정의 된다.
		arr는 0개 이상의 요소를 갖는 배열, item 은 배열에 저장된 요소, n은 배열의 최대 크기
		
	- 추상 자료형 정의
		= Array Create (n) ::= 배열의 크기가 n인 배열을 생성하고 반환.
		= Element Retrieve (arr, i, n) ::= 
			if (i∈index) 
			{
				return arr 의 인덱스 i 에 해당하는 요소를 반환.
			}
			else
			{
				return 에러
			}
		= Array Store(arr, i, item) ::=
			if (i∈index) 
			{
				return arr의 인덱스 i 에 해당하는 요소에 item 을 저장하고 arr을 반환.
			}
			else
			{
				return 에러
			}
		= Array Insert(arr, i, item, n) ::=
			if (i∈index) 
			{
				arr 의 요소를 i번째부터 n + 1 만큼 shift
				return arr의 인덱스 i 에 해당하는 요소에 item 을 저장하고 arr을 반환.
			}
			else
			{
				return 에러
			}
		= Array Remove(arr, i, item, n) ::=
			if (i∈index) 
			{
				arr 의 요소를 i번째부터 n - 1 만큼 shift
				return arr의 인덱스 i 에 해당하는 요소에 item 을 저장하고 arr을 반환.
			}
			else
			{
				return 에러
			}
		
	
3. 시간 복잡도(Time Complexity)
	- 삽입/삭제
		= 배열의 맨 앞에 삽입/삭제하는 경우 : Insert/Remove(n) = Big-O Notation = O(n)
		= 배열의 맨 뒤에 삽입/삭제하는 경우 : Insert/Remove(1) = Big-O Notation = O(1)
		= 배열의 중간에 삽입/삭제하는 경우 : Insert/Remove(n) = Big-O Notation = O(n)
		
	- 탐색
		= Retrieve(1) = Big-O Notation = O(1)
		
4. 장점
	- 인덱스를 가지고 있어 바로 접근 가능(비순차적 접근 가능) / (Big-O Notation = O(1))
		= 자료구조의 크기가 클수록 더 강력한 장점, 탐색에 매우 용이
	
5. 단점
	- 삽입과 삭제가 어렵고 오래 걸린다.
		= 원소를 삽입하거나 삭제할 경우, 해당 원소 이후의 모든 요소들을 한칸씩 밀거나 당겨야 한다.(연속된 메모리 공간에 저장되기 때문)
		= 단점을 보완한 Linked list 가 있음.
	- 배열의 크기를 바꾸기 위해서는 리소스 발생.
		= 배열은 처음 생성할 때 크기를 설정함.
		= 크기를 변경하기 위해서는 원하는 크기의 새로운 배열을 선언한 뒤 값을 복사해야 함.
	- 연속된 메모리라서 공간 낭비가 발생
		= 중간에 데이터가 삭제되면 공간 낭비가 발생할 수 있음. 또, 처음에 배열 크기를 100으로 생성했는데 10정도 밖에 쓰지 않으면 나머지 공간은 빈 공간으로 낭비가 발생함.